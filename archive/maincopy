



# main_agentos.py

import os
import json
import asyncio
from typing import Annotated

# GenAI Session and LangChain Imports
from genai_session.session import GenAISession
from genai_session.utils.context import GenAIContext
from langchain_google_genai import ChatGoogleGenerativeAI

# Your existing Agent classes (no changes needed for these)
from agentos import Agent

# --- Agent JWT Configuration ---
# TODO: Replace each placeholder with a unique Agent JWT from the GenAI OS platform
PLANNER_AGENT_JWT = "your_planner_agent_jwt_here"
EXECUTOR_AGENT_JWT = "your_executor_agent_jwt_here"
AUDITOR_AGENT_JWT = "your_auditor_agent_jwt_here"
FULL_STACK_AGENT_JWT = "your_full_stack_agent_jwt_here"

# --- Session Initialization for Each Agent ---
planner_session = GenAISession(jwt_token=PLANNER_AGENT_JWT)
executor_session = GenAISession(jwt_token=EXECUTOR_AGENT_JWT)
auditor_session = GenAISession(jwt_token=AUDITOR_AGENT_JWT)
full_stack_session = GenAISession(jwt_token=FULL_STACK_AGENT_JWT)

# --- LLM Initialization ---
# This single LLM instance can be shared by all agents.
llm = ChatGoogleGenerativeAI(model="gemini-1.5-pro-latest")

# --- Core Agent Logic (Classes) ---
# These classes contain the synchronous, core logic for each specialist agent.

class PlannerAgent(Agent):
    """AGENT 1: The Planner."""
    def __init__(self, llm_instance):
        super().__init__()
        self.name = "PlannerAgent"
        self.system_prompt = """
You are the Green-Stack Planner. Analyze the user's request and create a JSON plan.
Your output MUST be a JSON object with "components" and "optimizations" keys.
### SUSTAINABLE HEURISTICS RULEBOOK ###
- NextGenFormats: If images are mentioned, use .webp/.avif.
- LazyLoading: For below-the-fold content, use React.lazy().
- ResponsiveImages: For primary images, use the srcset attribute.
- CodeSplitting: For large, non-critical UI sections (charts, modals), code-split.
- Memoization: For any lists or grids, wrap items in React.memo.
- UseCSSVariablesForThemes: For theming (e.g., dark mode), use CSS Variables.
### END RULEBOOK ###
USER REQUEST: "{user_request}"
YOUR JSON PLAN:
"""
        self.llm = llm_instance

    def run(self, user_request: str) -> dict:
        prompt = self.system_prompt.format(user_request=user_request)
        response = self.llm.invoke(prompt)
        cleaned_response = response.content.strip().replace("```json", "").replace("```", "")
        return json.loads(cleaned_response)

class ExecutorAgent(Agent):
    """AGENT 2: The Executor."""
    def __init__(self, llm_instance):
        super().__init__()
        self.name = "ExecutorAgent"
        self.system_prompt = """
You are an expert React developer. Generate a single, self-contained React component that executes the following plan. The code should be functional and include styling.
EXECUTION PLAN:
{plan}
REACT CODE (HTML/JSX with inline CSS in a style tag):
"""
        self.llm = llm_instance
        
    def run(self, plan: dict) -> str:
        prompt = self.system_prompt.format(plan=json.dumps(plan, indent=2))
        response = self.llm.invoke(prompt)
        return response.content

class AuditorAgent(Agent):
    """AGENT 3: The Auditor."""
    def __init__(self, llm_instance):
        super().__init__()
        self.name = "AuditorAgent"
        self.report_prompt_template = "Format this data into a user-friendly markdown report: Eco-Grade: {grade}, Notes: {notes}"
        self.llm = llm_instance

    def run(self, plan: dict) -> dict:
        optimizations = plan.get("optimizations", [])
        components = plan.get("components", [])
        score = 100
        notes = []
        if "LazyLoading" in optimizations: score += 30; notes.append("✅ Implemented Lazy Loading (+30 pts)")
        if "Memoization" in optimizations: score += 20; notes.append("✅ Used Memoization (+20 pts)")
        is_list = any("List" in s or "Gallery" in s for s in components)
        if is_list and "Memoization" not in optimizations: score -= 15; notes.append("❌ Failed to memoize list items (-15 pts)")
        best_practices_score = min(max(score, 0), 100)
        page_weight_score = 85
        performance_score = 92
        eco_grade = (page_weight_score * 0.5) + (performance_score * 0.3) + (best_practices_score * 0.2)
        report_prompt = self.report_prompt_template.format(grade=eco_grade, notes=", ".join(notes))
        report_markdown = self.llm.invoke(report_prompt).content
        return {"report_markdown": report_markdown, "eco_grade": eco_grade}


# --- Registered Agent Definitions ---

@planner_session.bind(name="planner_agent", description="Creates a JSON plan from a user prompt.")
async def planner_agent(
    agent_context: GenAIContext,
    prompt: Annotated[str, "The user's request for code generation."]
) -> dict:
    """Entry point for the specialist planning agent."""
    planner = PlannerAgent(llm)
    return planner.run(user_request=prompt)

@executor_session.bind(name="executor_agent", description="Generates React code from a JSON plan.")
async def executor_agent(
    agent_context: GenAIContext,
    plan: Annotated[dict, "The JSON execution plan created by the planner_agent."]
) -> str:
    """Entry point for the specialist execution agent."""
    executor = ExecutorAgent(llm)
    return executor.run(plan=plan)

@auditor_session.bind(name="auditor_agent", description="Audits a JSON plan and returns an eco-report.")
async def auditor_agent(
    agent_context: GenAIContext,
    plan: Annotated[dict, "The JSON execution plan to be audited."]
) -> dict:
    """Entry point for the specialist auditor agent."""
    auditor = AuditorAgent(llm)
    return auditor.run(plan=plan)

@full_stack_session.bind(
    name="full_stack_agent",
    description="Orchestrates the planner, executor, and auditor to generate sustainable code."
)
async def full_stack_agent(
    agent_context: GenAIContext,
    prompt: Annotated[str, "The user's top-level request for code generation."]
) -> dict:
    """
    Orchestrator agent that performs the full plan->execute->audit workflow
    by calling other specialist agents.
    """
    print(f"Orchestrating agents for prompt: '{prompt}'")

    # 1. Call the Planner Agent to get the plan
    print("Calling planner_agent...")
    plan_result = await agent_context.call_agent("planner_agent", {"prompt": prompt})
    print("✅ Plan received from planner_agent.")

    # 2. Call the Executor and Auditor agents in parallel
    print("Calling executor_agent and auditor_agent in parallel...")
    executor_task = agent_context.call_agent("executor_agent", {"plan": plan_result})
    auditor_task = agent_context.call_agent("auditor_agent", {"plan": plan_result})
    
    # Wait for both agents to return their results
    results = await asyncio.gather(executor_task, auditor_task)
    generated_code = results[0]
    report_result = results[1]
    print("✅ Results received from executor and auditor.")
    
    # 3. Combine and return the final result
    return {
        "generatedCode": generated_code,
        "reportMarkdown": report_result["report_markdown"],
        "ecoGrade": report_result["eco_grade"]
    }

# --- Application Startup ---

async def main():
    """Main function to start all agents and process their events concurrently."""
    print("Starting all agents...")
    
    # Run all agent event loops concurrently
    await asyncio.gather(
        planner_session.process_events(),
        executor_session.process_events(),
        auditor_session.process_events(),
        full_stack_session.process_events(),
    )

if __name__ == "__main__":
    # This runs the main asyncio event loop for all registered agents.
    asyncio.run(main())
